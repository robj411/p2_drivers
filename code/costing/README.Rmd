---
title: "The Costing Model"
#date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::github_document2:
    # pandoc_args: --webtex
    toc: true
    toc_depth: 5
    toc_float: true
    number_sections: true
  bookdown::pdf_document2: 
    #   --filter=pandoc-xnos
    toc: false
    keep_tex: yes
    citation_package: natbib
    extra_dependencies: ["float"]
    # extra_dependencies: ["flafter"]
    # pandoc_args:
    number_sections: true
    fig_caption: yes
    # includes:
    #   in_header: "preamble.tex"
  bookdown::word_document2: 
    toc_depth: 5
    toc_float: true
    number_sections: true
    editor_options: 
      chunk_output_type: inline
bibliography: 
  - "../../epi.bib"
always_allow_html: true
---

<!-- # Figures (temporary) {.unlisted .unnumbered} -->

```{r setup, include=FALSE}
library(ggplot2)  
library(knitr)     
library(tidyr)
library(dplyr)
library(stringi)
library(gplots)
library(RColorBrewer)
library(data.table)
library(splines)
library(bookdown)
library(pander)
library(haven)
library(viridis)
library(hrbrthemes)
library(MASS)
library(kableExtra)
library(wbstats)
library("cowplot")
library(latex2exp)


panderOptions('round',2)
panderOptions('table.split.table', Inf)

knitr::opts_chunk$set(comment=NA, prompt=FALSE, cache=FALSE, echo=F, message=F, warning=F, results='asis')

format_to_print <- function(x,z=-1){
  formatC(round(x,z), format="f", digits=as.numeric(z>0), big.mark=",")
}

decimalplaces <- function(x) {
    if ((x %% 1) != 0) {
        nchar(strsplit(sub('0+$', '', as.character(format(x,scientific = F))), ".", fixed=TRUE)[[1]][[2]])
    } else {
        return(0)
    }
}

format_to_print2 <- function(x,z=2){
    v <- signif(x,z)
    sapply(v, function(i)  formatC(i, format="f", digits=decimalplaces(i), big.mark=","))
}

```

```{r ages, eval=FALSE}

# age data from owid
allpop = read.csv('population-by-five-year-age-group.csv')
ils = unique(allpop$Entity)[grepl('-income',unique(allpop$Entity))]
maxyear = max(allpop$Year)
ildata = subset(allpop,Entity%in%ils&Year==maxyear)
popcols = which(grepl('Population',colnames(ildata)))
col14 = which(grepl('14',colnames(ildata)))
col64 = which(grepl('64',colnames(ildata)))
for(i in 1:nrow(ildata)){
  print(ildata$Entity[i])
  print(sum(as.numeric(ildata[i,popcols[popcols>col14]])))
  print(sum(as.numeric(ildata[i,popcols[popcols>col64]])))
}

```





This document describes the costing model that is used in the CEPI application. 



# Overview

# Parameters

```{r echo=F,warning=F,message=F}

caps <- readODS::read_ods('cost_parameters.ods',sheet = 1)
caps$`Math notation` <- paste0('$',caps$`Math notation`,'$')
lg <- 'Notation and parametric assumptions for inputs to the costing model. Parameters are used as follows: uniform distributions go from Parameter 1 to Parameter 2. Triangular distributions go from Parameter 1 to Parameter 3 with a peak at Parameter 2. Multinomial distributions have equally probable values listed individually. Exponential distributions have as a mean Parameter 1 and are truncated at Parameters 2 and 3. Inverse Gaussian distributions have as a mean Parameter 1, as a shape Parameter 2, and are truncated at the bounds. Log normal distributions have as a mean Parameter 1, as a standard deviation Parameter 2, and are truncated at the bounds. Inverse Gamma distributions have shape Parameter 1, scale Parameter 2, and are truncated at the bounds. Beta Prime distributions have shape Parameters 1 and 2, scale Parameter 3, and are truncated at the bounds.'
cat(pander(caps,caption=lg, missing = ""))

```


```{r}
library(TruncExpFam)
library(EnvStats)
library(extraDistr)

# caps
# unique(caps$Distribution)
nsamples = 100
params <- pall <- list()

for(i in 1:nrow(caps)){
  parameters <- as.numeric(strsplit(caps$Parameters[i],',')[[1]])
  bounds <- as.numeric(strsplit(caps$Bounds[i],',')[[1]])
  if(caps$Distribution[i]=='Uniform'){
    params[[caps$Description[i]]] = runif(nsamples,parameters[1],parameters[2])
  }else if(caps$Distribution[i]=='Exponential'){
    params[[caps$Description[i]]] = rtruncexp(nsamples, rate = 1/parameters[1], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Inverse Gaussian'){ # s = dispersion
    params[[caps$Description[i]]] = rtruncinvgauss(nsamples, m = parameters[1], s = parameters[2], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Inverse Gamma'){ 
    samples = rinvgamma(nsamples, alpha = parameters[1], beta = parameters[2])
    fails = samples < bounds[1] | samples > bounds[2]
    while(sum(fails)>0){
      samples[fails] = rinvgamma(sum(fails), alpha = parameters[1], beta = parameters[2])
      fails = samples < bounds[1] | samples > bounds[2]
    }
    params[[caps$Description[i]]] = samples
    # params[[caps$Description[i]]] = rtruncinvgamma(nsamples, shape = parameters[1], scale = parameters[2], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Log normal'){ 
    params[[caps$Description[i]]] = rtrunclnorm(nsamples, meanlog = parameters[1], sdlog = parameters[2], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Beta prime'){ 
    samples = rbetapr(nsamples, shape1 = parameters[1], shape2 = parameters[2], scale = parameters[3])
    fails = samples < bounds[1] | samples > bounds[2]
    while(sum(fails)>0){
      samples[fails] = rbetapr(sum(fails), shape1 = parameters[1], shape2 = parameters[2], scale = parameters[3])
      fails = samples < bounds[1] | samples > bounds[2]
    }
    params[[caps$Description[i]]] = samples
  }else if(caps$Distribution[i]=='Triangular'){
    params[[caps$Description[i]]] = rtri(nsamples,min=parameters[1],mode=parameters[2],max=parameters[3])
  }else if(caps$Distribution[i]=='Multinomial'){
    values = na.omit(c(parameters))
    params[[caps$Description[i]]] = sample(values,size=nsamples,replace=T)
  }
  
  # params has only the samples; pall has also the constants
  if(caps$Distribution[i]=='Constant'){
    pall[[caps$Code[i]]] = parameters
  }else{
    pall[[caps$Code[i]]] = params[[caps$Description[i]]]
  }
}
```



# Model details



## Preparedness cost equation (annual calculation, 2025-2039)


(BPSV R&D + BPSV Stockpile + SARS-X Reserved capacity + Enabling activities) / (1 + discount rate) ^ (year – 2025)



## Response cost equation (annual calculation, 2040-2045)


(BPSV R&D + SARS-X R&D + BPSV Procurement + SARS-X Procurement + BPSV Delivery + SARS-X Delivery) / (1 + discount rate) ^ (year – 2025)



## Risk-adjusted R&D cost per candidate calculation

Sum of the cost of each phase multiplied by the likelihood of phase occurrence (probability of success for previous phases)


Probability of Occurrence (PoO) = 1 * PoS (PhaseN-1) ...

$ (Preclin) * PoO (Preclin) + $ (Ph1) * PoO (Ph1) + $ (Ph2) * PoO (Ph2) + $ (Ph3) * PoO (Ph3) + $ (License) * PoO (License)


Probabilities of success for preclinical, Phase I, Phase II, and Phase III are $P_0$, $P_1$, $P_2$ and $P_3$. Then probabilities of occurrence are:

$$\hat{P}_i = \left\\{\begin{array}{lr}1 & i=0 \\\\ \prod_{j=0}^{i-1}P_j & i\in\\{1,2,3\\} \\\\ \prod_{j=0}^{3}P_j & i=L \end{array}\right.$$

and the cost of each phase is $T_i$ (a (weighted) sum of experienced and inexperienced manufacturers?). Then the total cost is

$$D_{\text{RD}} = \sum_{i=0}^3 \hat{P}_iT_i + (1+I) \hat{P}_LL$$

where $I$ is inflation from 2018 to 2025.

## Procurement cost calculation

Scenario 1: Annual demand under 6.6B

Annual demand * $6.29 * 1.14 *1.2

Scenario 2: Annual demand over 6.6B

Annual demand * $18.94



If we write annual demand in billions as $A_{\cdot,y}$, then we would have costs, in billion USD, of:

$$D_{\text{SSV},y} = \min\\{A_{SSV,y},M_C\\}\cdot S_R\cdot(1+M_p)\cdot(1+M_f)  + \max\\{A_{SSV,y}-M_C,0\\}\cdot S_U$$

$$D_{\text{BPSV},y} = A_{BPSV,y}\cdot G$$


## Delivery Cost Equation

WB status demand/0.8 * 0.1 * (0-10% cost) +
WB status demand/0.8  * 0.2 * (11-30% cost) +
WB status demand/0.8 * 0.5 * (30-80% cost)


For populations aged 15 and above $N_i^{(15)}$ in income group $i\in\{\text{LIC, LMIC, UMIC, HIC}\}$, and delivery cost $D$:

$$D_{\text{SSV}} = \sum_{i}N_i^{(15)}\left(\frac{1}{8}V_{i; 0} + \frac{2}{8}V_{i; 11} + \frac{5}{8}V_{i; 31}\right) $$ 

For the BPSV, which goes only to people aged 65 or older, with populations $N_i^{(65)}$, coverage is reached earlier in the process, so the cost is weighted more heavily towards start up and ramp up:

$$D_{\text{BPSV}} = \sum_{i}D_{\text{BPSV},i}$$

$$D_{\text{BPSV},i} = 
\left\\{\begin{array}{lr}
N_i^{(65)}V_{i; 0}  & N_i^{(65)}\leq \frac{1}{8}N_i^{(15)} \\\\
\frac{N_i^{(15)}}{8} V_{i; 0} + \left(N_i^{(65)}-\frac{N_i^{(15)}}{8} \right)V_{i; 11}  & \frac{1}{8}N_i^{(15)} \leq N_i^{(65)}\leq \frac{2}{8}N_i^{(15)} \\\\
\frac{N_i^{(15)}}{8} V_{i; 0} + \frac{2}{8}N_i^{(15)} V_{i; 11} + \left(N_i^{(65)}-\frac{3}{8}N_i^{(15)} \right)V_{i; 31} & N_i^{(65)}> \frac{3}{8} N_i^{(15)}
\end{array}\right.$$ 





| Country | Country status | Study type | Financial Cost per dose (USD) | Source |
|---|---|---|---|---|
| WHO, Gavi, and UNICEF AMC Estimate | AMC | Top down | 1.66 | @Griffiths2021 |
| UNICEF Global Estimate |  All | Model | 0.73 | @Oyatoye2023 |
| DRC | LIC | Bottom up | 1.91 | @Moi2024 |
| Malawi | LIC | Bottom up | 4.55 | @Ruisch2025 |
| Mozambique | LIC | Bottom up | 0.5 | @Namalela2025 |
| Uganda | LIC | Bottom up | 0.79 | @Tumusiime2024 |
| Bangladesh | LMIC | Bottom up | 0.29 | @Yesmin2024 |
| Cote d'Ivoire | LMIC | Bottom up | 0.67 | @Vaughan2023 |
| Nigeria | LMIC | Bottom up | 0.84 | @Noh2024 |
| Philippines | LMIC | Bottom up | 2.16 | @Banks2023 |
| Vietnam | LMIC | Bottom up | 1.73 | @Nguyen2024 |
| Ghana | LMIC | CVIC tool | 2.2--2.3 | @Nonvignon2022 |
| Lao PDR | LMIC | CVIC tool | 0.79--0.81 | @Yeung2023 |
| Kenya | LMIC | Top down | 3.29--4.28 | @Orangi2022 | 
| Botswana | UMIC | Mixed | 19 | @Vaughan2025 |
| South Africa | UMIC | Top down | 3.84 | @Edoka2024 | 

Table: Literature review of global and country-specific delivery rates. 



## Vaccination Scenarios

Vaccine supply at each investment level is modelled by producing doses sourced from preexisting advance capacity reservations or from the private market. The production volumes for each of these supply mechanisms are interconnected and based on the following assumptions: 

- Current annual global vaccine manufacturing capacity is 9B doses and is used in the response to the SARS-X pandemic 
- A portion of this capacity is reserved in each level for pandemic response following the advance capacity reservation volumes in each investment level (see Table XX) 
- Advance capacity reservations allow manufacturing facilities to transition and scale production of SSV doses faster because facilities are paid to maintain a high level of transition preparedness and produce vaccines on the same platform as the approved SSV 
- Advance capacity reservation agreements guarantee a population-proportional distribution to all World Bank income groups as part of their terms and conditions (an exception is made for the 500m doses available in all levels, which comes from an existing advance capacity reservation held by the European Union) 
- Private manufacturing will respond to meet any additional gap in SSV demand above the volume covered by advance capacity reservations 
- Private manufacturing of the SARS-X vaccine will occur in all existing vaccine production facilities not under a reserved capacity agreement 
- Additional production capacity of 6B doses will be built in response to a global pandemic, like during the Covid-19 response 
- In BAU and half of scenarios, private manufacturers prioritise delivering SARS-X doses to HICs, like during the Covid-19 response. Private manufacturers provide population-proportional distribution to all income groups, following the same logic as advanced capacity reservations, in the remaining scenarios (see Table 2) 
- HICs initially receive SARS-X doses quicker than other World Bank income groups due to existing advance capacity reservations and preferential treatment from private manufacturers, in select scenarios. When HICs receive sufficient doses for vaccinating eligible populations, the prioritized doses are reallocated to UMICs. This process repeats for LLMICs once all UMICs doses are delivered 


| Category | Reserved capacity | Private response (existing capacity)  | Private response (built capacity)  |
|---|---|---|---|
| Annual manufacturing volume | By scenario (0.5--2.5B)| 2.5B minus reserved volume | 6B |
| Facility transition start | 7 weeks before vaccine approval | 7 weeks before vaccine approval | 7 weeks before vaccine approval |
| Weeks to initial manufacturing | 12 | 30 | 48 |
| Scale-up weeks to full capacity | 10 | 16 | 16 |

Table: Manufacturing response timeline assumptions 



 

<!-- | Weeks from transition start | 0-11 | 12-21 | 22-29 | 30-45  | 46-47 | 48-63 | 64+ | -->
<!-- |---|---|---|---|---|---|---|---| -->
<!-- | Reserved Capacity (%)  || Scaling from 0-100 | 100 | 100 | 100 | 100 | 100 |  -->
<!-- | Private Capacity (Existing; %)  || | | Scaling from 0-100 | 100 | 100 | 100 |  -->
<!-- | Private Capacity (Response; %)  | | | |  | | Scaling from 0-100 | 100 | -->

 

| Weeks from transition start |	Reserved Capacity (%)	 | Private Capacity (Existing; %)	| Private Capacity (Response; %) |
|---|---|---|---|
| 0--11 |  |  |  |			
| 12--21 |	Scaling from 0-100	 |  |  |				
| 22--29 |	100		|   |  |			
| 30--45 |	100 |	Scaling from 0-100	  |  |
| 46--47 |	100 |	100	  |  |
| 48--63	 |100 |	100 |	Scaling from 0-100 |
| 64+|	100 |	100 |	100 |

Table: Vaccine Production Timeline


## Vaccine supply 

### Timing

Facility transition occurs $F=7$ weeks before vaccine approval, which in turn depends on R\&D investments. We have three levels in our scenarios, corresponding to a 100 Days Mission, 200 days, and 365 days. The total weeks taken for vaccine approval can be written as follows:

$$W_{j}^{(S)} = \sum_{i=0}^3 W_{i;j}^{(S)}$$

```{r}
dms = c(365, 200, 100)

time_to_approval = c()
for(j in 1:length(dms)){
  pars = names(pall)[grepl('weeks_P',names(pall)) & grepl(dms[j],names(pall))]
  time_to_approval[j] = 0
  for(i in pars){
    time_to_approval[j] = time_to_approval[j] + pall[[i]]
  }
}

```

for $j\in\\{365, 200, 100\\}$. These work out as `r time_to_approval[1]`, `r time_to_approval[2]`, and `r time_to_approval[3]` weeks, respectively. Thus "week 0" for manufacturing occurs `r time_to_approval[1]-7`, `r time_to_approval[2]-7`, and `r time_to_approval[3]-7` weeks, respectively, after the new pathogen has been sequenced. We denote this variable $w_s^{(0)}$.




### Production

The total global manufacturing volume is $M_G=15$ billion doses. The amount that is reserved, in billion doses, depends on the scenarios as follows:

$$M_{R,s} = \left\\{\begin{array}{lr}0.5 & s\in\\{0, 1, 6, 9, 12\\} \\\\ 
1.2 & s\in\\{2, 4, 7, 10\\} \\\\ 
2.5 & s\in\\{3, 5, 8, 11\\} \end{array}\right.$$

where $s=0$ denotes the BAU scenario. By definition, $M_{E,s} = M_C - M_{R,s}$, and $M_B=M_G-M_C$.

Then the number of doses, in billions, that are made from capacity $x\in \\{R, E, B\\}$ in week $w$ of scenario $s$ is:


$$Z_{x,s,w} = \left\\{\begin{array}{lr}0 & w-w_s^{(0)} < I_x \\\\ 
\frac{1}{52}\frac{w-w_s^{(0)}-I_x+1}{C_x}M_{x,s} & w-w_s^{(0)}\in[I_x, I_x+C_x) \\\\ 
\frac{1}{52}M_{x,s}  & w-w_s^{(0)}\geq I_x+C_x
\end{array}\right.$$

<!-- \frac{1}{52}M_{R,s}  & w\in[I_R+C_R, I_E)\\\\  -->
<!-- \frac{1}{52}\left(M_{R,s} + \frac{w-I_E+1}{C_E}M_{E,s}\right) & w\in[I_E, I_E+C_E)\\\\  -->
<!-- \frac{1}{52}\left(M_{R,s} + M_{E,s}\right)  & w\in[I_E+C_E, I_B)\\\\  -->
<!-- \frac{1}{52}\left(M_{R,s} + M_{E,s} + \frac{w-I_B+1}{C_B}M_{B}\right) & w\in[I_B, I_B+C_B)\\\\  -->

where $I_R=12$ is the number of weeks to initial manufacturing for reserved capacity, $C_R=10$ is the number of weeks to scale up to full capacity; $I_E=30$ is the number of weeks to initial manufacturing for existing and unreserved capacity, $C_E=16$ is the number of weeks to scale up to full capacity; $I_B=48$ is the number of weeks to initial manufacturing for built and unreserved capacity, $C_B=16$ is the number of weeks to scale up to full capacity.

Then the total number of doses produced in week $w$ is $$Z_{T,s,w} = Z_{R,s,w}+Z_{E,s,w}+Z_{B,s,w}.$$

```{r supply, fig.cap='Doses made available from manufacturing per scenario. Weeks are in reference to the sequencing of the pathogen.'}


scen_dm = c(1, 1,1,1, 1,1, 2,2,2, 3,3,3, 1)
scen_capres = c(1, 1,2,3, 2,3, 1,2,3, 1,2,3, 1)

dose_supply = function(week, w0, weeks_init, weeks_scale, man_cap){
  if((week - w0) < weeks_init){
    doses = 0
  }else if((week - w0) < (weeks_init + weeks_scale)){
    doses = man_cap/52 * (week - w0 - weeks_init + 1) / weeks_scale
  }else{
    doses = man_cap/52
  }
  return(doses)
}

nweeks = 200
suffixes = c('res','ex','bui')
weeks_init = sapply(suffixes,function(x)pall[[paste0('weeks_init_',x)]])
weeks_scale = sapply(suffixes,function(x)pall[[paste0('weeks_scale_',x)]])
supplies <- cumulative <- list()
for(i in 1:length(scen_dm)){
  supplies[[i]] = list()
  
  w0 = time_to_approval[scen_dm[i]]
  man_cap_res = c(0.5, 1.2, 2.5)[scen_capres[i]]
  
  man_cap_ex = pall$man_curr - man_cap_res
  man_cap_bui = pall$man_glo - pall$man_curr
  
  man_cap = c(man_cap_res, man_cap_ex, man_cap_bui)
  names(man_cap) = suffixes
  
  for(x in suffixes){
    supplies[[i]][[x]] = c()
    for(w in 1:nweeks){
      supplies[[i]][[x]][w] = dose_supply(week=w, w0=w0, weeks_init=weeks_init[[x]], weeks_scale=weeks_scale[[x]], man_cap=man_cap[[x]])
    }
  }
  
  cumulative[[i]] = cumsum(Reduce("+",supplies[[i]]))
  
}

scennames = c('BAU',paste0('S',sprintf("%02d", 1:12)))

t_supply <- as.data.frame(do.call(rbind,lapply(1:length(scennames),function(x)cbind(scen=scennames[x],doses=cumulative[[x]],week=1:nweeks))))

ggplot(t_supply) + 
  geom_line(aes(x=as.numeric(week),y=as.numeric(doses),colour=factor(scen,levels=scennames))) +
  theme_bw(base_size = 15) +
  labs(x='Week',y='Cumulative doses, billions',colour='Scenario')

scens = setDT(data.frame(scen=scennames, capres = scen_capres, dm = scen_dm))
scens[,comb := paste0(capres,dm)]
scens[,N:=.N,by=comb]
sames <- list()
for(un in unique(scens$comb)){
  subscen = subset(scens,comb==un)
  if(nrow(subscen)>1)
    sames[[length(sames)+1]] <- subscen$scen
}

```

In Figure \@ref(fig:supply), the following scenarios have identical supply (because they have the same capacity reservations and R\&D investments): `r paste0(sames[[1]],collapse=' & ')`; `r paste0(sames[[2]],collapse=' & ')`; and `r paste0(sames[[3]],collapse=' & ')`.

### Allocation

Denote the weekly allocated doses at week $w$ from capacity $x$ to income level $k_{s,x,i,w}$, and the cumulative number $K_{s,i,w}$, such that $$K_{s,i,w} = \sum_{x\in\\{R,E,B\\}}\sum_{j=0}^w k_{s,x,i,j}.$$ We write $X_i = 2\cdot 0.8\cdot N_i^{(15)}$ as the maximum demand for income group $i$, representing two doses each for 80\% of the population.

$$
k_{s,R,i,w} = \left\\{ \begin{array}{lr}
Z_{R,s,w}             & K_{s,\text{HIC},w} < 0.5 \\;\\&\\; i=\text{HIC} \\\\
0                     & K_{s,\text{HIC},w} < 0.5 \\;\\&\\; i\neq\text{HIC} \\\\
\frac{N_{i}}{N_{HIC}+N_{UMIC}+N_{LLMIC}}Z_{R,s,w} & 0.5 < K_{s,\text{HIC},w} < X_{\text{HIC}} \\\\
\frac{N_{i}}{N_{UMIC}+N_{LLMIC}}Z_{R,s,w} & K_{s,\text{HIC},w} \geq X_{\text{HIC}} \\;\\&\\;  K_{s,\text{UMIC},w} < X_{\text{HIC}} \\;\\&\\; i\neq\text{HIC}\\\\
Z_{R,s,w}             & K_{s,\text{UMIC},w} \geq X_{\text{UMIC}} \\;\\&\\; i=\text{LLMIC}
\end{array}\right.
$$

The logic of this reads as follows:

- The first 500 million doses from reserved capacity go exclusively to HIC
- None go to UMIC and LLMIC
- When HIC coverage is between 500 million and its total demand, reserved capacity doses are allocated according to population
- Once HIC reach their total demand, doses from reserved capacity are split proportional to population between UMIC and LLMIC
- Once UMIC reach their total demand, all doses from reserved capacity go to LLMIC




For $x\in\\{E,B\\}$,

$$
k_{s,x,i,w} = \left\\{ \begin{array}{lr}
Z_{x,s,w}            & K_{s,\text{HIC},w} < X_{\text{HIC}} \\;\\&\\; i=\text{HIC} \\\\
0                     & K_{s,\text{HIC},w} < X_{\text{HIC}} \\;\\&\\; i\neq\text{HIC} \\\\
Z_{x,s,w}            & K_{s,\text{HIC},w} \geq X_{\text{HIC}} \\;\\&\\; K_{s,\text{UMIC},w} < X_{\text{UMIC}} \\;\\&\\; i=\text{UMIC} \\\\
0                     & K_{s,\text{HIC},w} \geq X_{\text{HIC}} \\;\\&\\; K_{s,\text{UMIC},w} < X_{\text{UMIC}} \\;\\&\\; i\neq\text{UMIC} \\\\
Z_{x,s,w}            & K_{s,\text{UMIC},w} \geq X_{\text{UMIC}} \\;\\&\\; i=\text{LLMIC} \\\\
0                     & K_{s,\text{UMIC},w} \geq X_{\text{UMIC}} \\;\\&\\; i\neq\text{LLMIC} 
\end{array}\right.
$$

The logic of this reads as follows:

- Until HIC demand is reached, all doses from unreserved capacity go to HIC
- None go to UMIC and LLMIC
- Once HIC demand has been met and until UMIC demand is reached, all doses from unreserved capacity go to UMIC
- None go to HIC and LLMIC
- Once HIC and UMIC demand have been met, all remaining doses from unreserved capacity go to LLMIC
- None go to UMIC and HIC


```{r}

pops = sapply(names(pall)[grepl('15',names(pall))&grepl('pop',names(pall))],function(x)pall[[x]])
pops3 = pops[1:3]
pops3[3] = sum(pops[3:4])

demand15 = 0.8*pops3*2
popfracs15 = pops3/sum(pops3)


allocate_res_doses = function(cum_received, new_doses){
  if(cum_received[1] < 0.5){
    allocation = c(new_doses, 0, 0)
  }else if(cum_received[1] < demand15[1]/1e9){
    allocation = new_doses * popfracs15
  }else if(cum_received[2] < demand15[2]/1e9){
    allocation = c(0, new_doses * pops3[2:3]/sum(pops3[2:3]))
  }else if(cum_received[3] < demand15[3]/1e9){
    allocation = c(0,0,new_doses)
  }else{
    allocation = c(0,0,0)
  }
  return(allocation)
}

allocate_exbui_doses = function(cum_received, new_doses){
  if(cum_received[1] < demand15[1]/1e9){
    allocation = c(new_doses, 0, 0)
  }else if(cum_received[2] < demand15[2]/1e9){
    allocation = c(0, new_doses, 0)
  }else if(cum_received[3] < demand15[3]/1e9){
    allocation = c(0,0,new_doses)
  }else{
    allocation = c(0,0,0)
  }
  return(allocation)
}


pop_proportional = c(1,1,2,2,1,1,1,2,2,1,2,2,2)
function_list = list(res=allocate_res_doses, ex=allocate_exbui_doses, bui=allocate_exbui_doses)
rep_res = list(res=allocate_res_doses, ex=allocate_res_doses, bui=allocate_res_doses)

alloc = list()

for(s in 1:length(scennames)){
  cumulative_doses = matrix(0,nrow=nweeks,ncol=3)
  function_op = list(function_list, rep_res)[[pop_proportional[s]]]
  for(w in 2:nweeks){
    current_count = cumulative_doses[w-1,]
    
    for(x in suffixes){
      new_doses = supplies[[s]][[x]][w]
      allocation_res = function_op[[x]](cum_received = current_count, new_doses=new_doses)
      current_count = current_count + allocation_res
    }
    
    cumulative_doses[w,] = current_count
  }
  alloc[[s]] = as.data.frame(cumulative_doses)
  alloc[[s]]$Scenario = scennames[s]
  alloc[[s]]$Week = 1:nweeks
  colnames(alloc[[s]])[1:3] = c('HIC','UMIC','LLMIC')
}

ggplot(reshape2::melt(do.call(rbind,alloc),id.vars=c('Scenario','Week'))) +
  geom_line(aes(x=Week,colour=Scenario,y=value)) +
  facet_wrap(~variable) +
  theme_bw(base_size = 15) +
  labs(x='Week',y='Cumulative doses, billions',colour='Scenario')

```

### Distribution

```{r}

incomelevels = c('HIC','UMIC','LLMIC')
rates = matrix(rep(c(.07, .07, .02), length(scennames)),ncol=length(incomelevels),byrow=T)
rates[13,3] = 0.04

second_dose_delivery <- list()
for(s in 1:nrow(rates)){
  second_dose_delivery[[s]] <- list()
  for(il in 1:ncol(rates)){
    rateperdose = rates[s,il]/2
    # new doses in per week
    doses_per_week = c(0, diff(alloc[[s]][,il]))
    first_doses <- second_doses <- c()
    doses_left = 0
    for(w in 1:nweeks){
      # doses this week = stock plus flow
      doses_left = doses_left + doses_per_week[w]
      # first doses given are the minimum of: the delivery rate; the doses left (per population); the fraction of the population still unvaccinated
      first_doses[w] =  min(rateperdose, doses_left/(pops3[il]/1e9), max(0,demand15[il]/pops3[il]/2 - sum(first_doses)) )
      # subtract doses given to update the stock
      doses_left = doses_left - first_doses[w]
      if(w>3){
        # second doses given are the minimum of: the delivery rate; the doses left (per population); the fraction of the population vaccinated once, at least three weeks ago, but not twice.
        second_doses[w] = min(rateperdose, doses_left/(pops3[il]/1e9), max(0, sum(first_doses[1:(w-3)])-sum(second_doses)))
        # subtract doses given to update the stock
        doses_left = doses_left - second_doses[w]
      }else{
        second_doses[w] = 0
      }
    }
    second_dose_delivery[[s]][[il]] = data.frame(doses=cumsum(second_doses), il=incomelevels[il], Week=1:nweeks)
  }
  second_dose_delivery[[s]] = do.call(rbind,second_dose_delivery[[s]])
  second_dose_delivery[[s]]$Scenario = scennames[s]
}


ggplot(do.call(rbind,second_dose_delivery)) +
  geom_line(aes(x=Week,colour=Scenario,y=doses)) +
  facet_wrap(~factor(il,levels=incomelevels)) +
  theme_bw(base_size = 15) +
  labs(x='Week',y='Cumulative doses, billions',colour='Scenario')


```




# Results

## Parameter samples

```{r}

for(i in 1:length(params))
  base::print(
    ggplot() + 
      geom_histogram(aes(x=params[[i]])) + 
      theme_bw(base_size = 13) + 
      labs(x='',y='',title=names(params)[i])
    )

```


## Preparedness costs

## Response costs

## R&D costs

## Procurement costs

## Delivery costs

## Manufacture

## Vaccination scenarios

# Attributions / Authors

# References
