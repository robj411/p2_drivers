---
title: "The Costing Model"
#date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::github_document2:
    # pandoc_args: --webtex
    toc: true
    toc_depth: 5
    toc_float: true
    number_sections: true
  bookdown::pdf_document2: 
    #   --filter=pandoc-xnos
    toc: false
    keep_tex: yes
    citation_package: natbib
    extra_dependencies: ["float"]
    # extra_dependencies: ["flafter"]
    # pandoc_args:
    number_sections: true
    fig_caption: yes
    # includes:
    #   in_header: "preamble.tex"
  bookdown::word_document2: 
    toc_depth: 5
    toc_float: true
    number_sections: true
    editor_options: 
      chunk_output_type: inline
bibliography: 
  - "../../epi.bib"
always_allow_html: true
---

<!-- # Figures (temporary) {.unlisted .unnumbered} -->

```{r setup, include=FALSE}
library(ggplot2)  
library(knitr)     
library(tidyr)
library(dplyr)
library(stringi)
library(gplots)
library(RColorBrewer)
library(data.table)
library(splines)
library(bookdown)
library(pander)
library(haven)
library(viridis)
library(hrbrthemes)
library(MASS)
library(kableExtra)
library(wbstats)
library("cowplot")
library(latex2exp)

library(TruncExpFam)
library(EnvStats)
library(extraDistr)


panderOptions('round',2)
panderOptions('table.split.table', Inf)

knitr::opts_chunk$set(comment=NA, prompt=FALSE, cache=FALSE, echo=F, message=F, warning=F, results='asis')

format_to_print <- function(x,z=-1){
  formatC(round(x,z), format="f", digits=as.numeric(z>0), big.mark=",")
}

decimalplaces <- function(x) {
    if ((x %% 1) != 0) {
        nchar(strsplit(sub('0+$', '', as.character(format(x,scientific = F))), ".", fixed=TRUE)[[1]][[2]])
    } else {
        return(0)
    }
}

format_to_print2 <- function(x,z=2){
    v <- signif(x,z)
    sapply(v, function(i)  formatC(i, format="f", digits=decimalplaces(i), big.mark=","))
}

nsamples = 100

```

```{r ages, eval=FALSE}

# age data from owid
allpop = read.csv('population-by-five-year-age-group.csv')
ils = unique(allpop$Entity)[grepl('-income',unique(allpop$Entity))]
maxyear = max(allpop$Year)
ildata = subset(allpop,Entity%in%ils&Year==maxyear)
popcols = which(grepl('Population',colnames(ildata)))
col14 = which(grepl('14',colnames(ildata)))
col64 = which(grepl('64',colnames(ildata)))
for(i in 1:nrow(ildata)){
  print(ildata$Entity[i])
  print(sum(as.numeric(ildata[i,popcols[popcols>col14]])))
  print(sum(as.numeric(ildata[i,popcols[popcols>col64]])))
}

```





This document describes the costing model that is used in the CEPI application. 



# Overview

# Parameters

```{r paramtable, echo=F,warning=F,message=F}

caps <- readODS::read_ods('cost_parameters.ods',sheet = 1)
caps$`Math notation` <- paste0('$',caps$`Math notation`,'$')
lg <- 'Notation and parametric assumptions for inputs to the costing model. Parameters are used as follows: uniform distributions go from Parameter 1 to Parameter 2. Triangular distributions go from Parameter 1 to Parameter 3 with a peak at Parameter 2. Multinomial distributions have equally probable values listed individually. Exponential distributions have as a mean Parameter 1 and are truncated at Parameters 2 and 3. Inverse Gaussian distributions have as a mean Parameter 1, as a shape Parameter 2, and are truncated at the bounds. Log normal distributions have as a mean Parameter 1, as a standard deviation Parameter 2, and are truncated at the bounds. Inverse Gamma distributions have shape Parameter 1, scale Parameter 2, and are truncated at the bounds. Beta Prime distributions have shape Parameters 1 and 2, scale Parameter 3, and are truncated at the bounds.'
cat(pander(caps,caption=lg, missing = ""))

```


```{r sample}


params <- pall <- list()

for(i in 1:nrow(caps)){
  parameters <- as.numeric(strsplit(caps$Parameters[i],',')[[1]])
  bounds <- as.numeric(strsplit(caps$Bounds[i],',')[[1]])
  if(caps$Distribution[i]=='Uniform'){
    params[[caps$Description[i]]] = runif(nsamples,parameters[1],parameters[2])
  }else if(caps$Distribution[i]=='Exponential'){
    params[[caps$Description[i]]] = rtruncexp(nsamples, rate = 1/parameters[1], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Inverse Gaussian'){ # s = dispersion
    params[[caps$Description[i]]] = rtruncinvgauss(nsamples, m = parameters[1], s = parameters[2], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Inverse Gamma'){ 
    samples = rinvgamma(nsamples, alpha = parameters[1], beta = parameters[2])
    fails = samples < bounds[1] | samples > bounds[2]
    while(sum(fails)>0){
      samples[fails] = rinvgamma(sum(fails), alpha = parameters[1], beta = parameters[2])
      fails = samples < bounds[1] | samples > bounds[2]
    }
    params[[caps$Description[i]]] = samples
    # params[[caps$Description[i]]] = rtruncinvgamma(nsamples, shape = parameters[1], scale = parameters[2], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Log normal'){ 
    params[[caps$Description[i]]] = rtrunclnorm(nsamples, meanlog = parameters[1], sdlog = parameters[2], a = bounds[1], b = bounds[2], faster = T)
  }else if(caps$Distribution[i]=='Beta prime'){ 
    samples = rbetapr(nsamples, shape1 = parameters[1], shape2 = parameters[2], scale = parameters[3])
    fails = samples < bounds[1] | samples > bounds[2]
    while(sum(fails)>0){
      samples[fails] = rbetapr(sum(fails), shape1 = parameters[1], shape2 = parameters[2], scale = parameters[3])
      fails = samples < bounds[1] | samples > bounds[2]
    }
    params[[caps$Description[i]]] = samples
  }else if(caps$Distribution[i]=='Triangular'){
    params[[caps$Description[i]]] = rtri(nsamples,min=parameters[1],mode=parameters[2],max=parameters[3])
  }else if(caps$Distribution[i]=='Multinomial'){
    values = na.omit(c(parameters))
    params[[caps$Description[i]]] = sample(values,size=nsamples,replace=T)
  }
  
  # params has only the samples; pall has also the constants
  if(caps$Distribution[i]=='Constant'){
    pall[[caps$Code[i]]] = parameters
  }else{
    pall[[caps$Code[i]]] = params[[caps$Description[i]]]
  }
}
```






# Preparedness cost equation 


<span style="color:red;"> (BPSV R&D + BPSV Stockpile + SARS-X Reserved capacity + Enabling activities) / (1 + discount rate) ^ (year – 2025) </span>

$$D_y^{\text{(prep)}} = \frac{1}{(1+r)^y}\left(D_s^{\text{(BP-adRD)}} + D_s^{\text{(BP-inv)}} + D_s^{\text{(S-cap)}} + E_y\right)$$

- $D_s^{\text{(BP-adRD)}}$ is the R\&D cost of BPSV prior to an outbreak; see Equation \@ref(eq:bpsvrd)
- $D_s^{\text{(BP-inv)}}$ is the cost of maintaining an investigational reserve of 100,000 BPSV doses; see Equation \@ref(eq:bpsvinv)
- $D_s^{\text{(S-cap)}}$ is the cost of reserved capacity for SSV; see Equation \@ref(eq:ssvcap)
- $E_y$ is the annual cost of enabling activities, equal to `r pall$cost_enab` million USD per year.


## BPSV advanced R\&D

\begin{equation}
D_s^{\text{(BP-adRD)}} = 
(\#eq:bpsvrd)
\end{equation}

```{r posbpsv}
# probability of success is a parameter
pos = sapply(paste0('pos_',0:2),function(x) pall[[x]])
# probability to occur is the product of prior phases
pto = t(apply(pos[,1:2], 1, function (y) sapply(1:length(y),function(x) prod(y[1:x]))))

# save bpsv from phase 2 for later
pto_bpsv_phase3 = pall$n_bpsv_candidates*pto[,2]*pos[,3]

# add 1 column for probability of phase 0 to occur
pto = cbind(1, pto)

# costs are parameters
inex = sapply(paste0('cost_',0:2,'_inex'),function(x) pall[[x]])
ex = sapply(paste0('cost_',0:2,'_ex'),function(x) pall[[x]])
  
# weight should be a parameter
inex_weight = 0.5

# cost per phase is a weighted sum
costs = inex_weight * inex + (1-inex_weight) * ex

bpsv_rd_costsamples = rowSums(costs*pto)

ggplot() + geom_histogram(aes(8*bpsv_rd_costsamples/1e9)) +
  theme_bw(base_size=15) +
  labs(x='Billion USD',y='',title='Risk-adjusted R&D cost for 8 BPSV candidates')


```

## BPSV investigational reserve

The cost per dose per year is `r pall$cost_bpsvinv` USD, denoted $A_1$. Then the cost to maintain the reserve of 100,000 doses is

\begin{equation}
D_s^{\text{(BP-inv)}} = 100000 A_1
(\#eq:bpsvinv)
\end{equation}

for the scenarios that include a BPSV (S01, S02, S03).

## SSV capacity reservation

The cost per dose reservation per year is `r pall$cost_capres` USD, denoted $A_2$. Reservation sizes depend on scenarios as follows:

$$M_{R,s} = \left\\{\begin{array}{lr}0.5 & s\in\\{0, 1, 6, 9, 12\\} \\\\ 
1.2 & s\in\\{2, 4, 7, 10\\} \\\\ 
2.5 & s\in\\{3, 5, 8, 11\\} \end{array}\right.$$

Then the total cost per year is

\begin{equation}
D_s^{\text{(S-cap)}} =  M_{R,s} A_2
(\#eq:ssvcap)
\end{equation}


# Response cost equation 


<span style="color:red;"> (BPSV R&D + SARS-X R&D + BPSV Procurement + SARS-X Procurement + BPSV Delivery + SARS-X Delivery) / (1 + discount rate) ^ (year – 2025) </span>


$$D_y^{\text{(res)}} = \frac{1}{(1+r)^y}\left(D_s^{\text{(BP-resRD)}} + D_s^{\text{(S-RD)}} + D_s^{\text{(BP-proc)}} + D_{s}^{\text{(S-proc)}} + D_s^{\text{(BP-del)}} + D^{\text{(S-del)}}\right)$$

- $D_s^{\text{(BP-resRD)}}$ is the R\&D cost of BPSV after an outbreak; see Equation \@ref(eq:bpsvresrd)
- $D_s^{\text{(S-RD)}}$ is the R\&D cost for SSV; see Equation \@ref(eq:ssvrd)
- $D_s^{\text{(BP-proc)}}$ is the cost of procuring BPSV; see Equation \@ref(eq:bpsvproc)
- $D_{s}^{\text{(S-proc)}}$ is the cost of procuring SSV; see Equation \@ref(eq:ssvproc)
- $D_s^{\text{(BP-del)}}$ is the cost of delivering BPSV; see Equation \@ref(eq:bspvdel)
- $D^{\text{(S-del)}}$ is the cost of delivering SSV; see Equation \@ref(eq:ssvdel)





## Risk-adjusted R&D cost per candidate calculation

<span style="color:red;"> Sum of the cost of each phase multiplied by the likelihood of phase occurrence (probability of success for previous phases) </span>


<span style="color:red;"> Probability of Occurrence (PoO) = 1 * PoS (PhaseN-1) ... </span>

<span style="color:red;"> $ (Preclin) * PoO (Preclin) + $ (Ph1) * PoO (Ph1) + $ (Ph2) * PoO (Ph2) + $ (Ph3) * PoO (Ph3) + $ (License) * PoO (License) </span>

### SSV

**I have set the weight of inexperienced manufacturer to 0.5**

Probabilities of success for preclinical, Phase I, Phase II, and Phase III are $P_0$, $P_1$, $P_2$ and $P_3$. Then probabilities of occurrence are:

$$\hat{P}_i = \left\\{\begin{array}{lr}1 & i=0 \\\\ \prod_{j=0}^{i-1}P_j & i\in\\{1,2,3\\} \\\\ \prod_{j=0}^{3}P_j & i=L \end{array}\right.$$

and the cost of each phase is $T_i$, a weighted average of experienced and inexperienced manufacturers (assuming $\omega=0.5$), adjusted for the duration of the trial, which depends on the R\&D investment, denoted $x\in\{365, 200, 100\}$: $$T_{x,i} = \frac{W_{i;x}^{(S)}}{W_{i;365}^{(S)}}\left(\omega T_i^{(n)} + (1-\omega)T_i^{(e)}\right).$$ Then the total cost is

\begin{equation}
D_s^{\text{(S-RD)}} = 18\left(\sum_{i=0}^3 \hat{P}_iT_{x(s),i} + (1+I) \hat{P}_LL\right)
(\#eq:ssvrd)
\end{equation}

where $I$ is inflation from 2018 to 2025. For our scenarios, we have 

$$x(s) = \left\\{\begin{array}{lr} 365 & s\in\\{0, 1, 2, 3, 4, 5, 12\\} \\\\ 
200 & s\in\\{6, 7, 8\\} \\\\ 
100 & s\in\\{9, 10, 11\\} \end{array}\right.$$

This is the cost per candidate. We multiply by 18 to get the total cost.


```{r phases}

dms = c(365, 200, 100)
time_to_approval = c()
phase_duration = matrix(0,length(dms),4)
for(j in 1:length(dms)){
  pars = names(pall)[grepl('weeks_P',names(pall)) & grepl(dms[j],names(pall))]
  time_to_approval[j] = 0
  for(i in 1:length(pars)){
    time_to_approval[j] = time_to_approval[j] + pall[[pars[i]]]
    phase_duration[j,i] = pall[[pars[i]]]
  }
}

```

```{r posssv}
# probability of success is a parameter
pos = sapply(paste0('pos_',0:3),function(x) pall[[x]])
# probability to occur is the product of prior phases
pto = t(apply(pos, 1, function (y) sapply(1:length(y),function(x) prod(y[1:x]))))

# add 1 column for probability of phase 0 to occur
pto = cbind(1, pto)

# costs are parameters
inex = sapply(paste0('cost_',0:3,'_inex'),function(x) pall[[x]])
ex = sapply(paste0('cost_',0:3,'_ex'),function(x) pall[[x]])
  
# cost per phase is a weighted sum
costs = inex_weight * inex + (1-inex_weight) * ex

timescale = t(apply(phase_duration,1,function(x)x/phase_duration[1,]))

costlist = lapply(1:length(dms),function(x) t(apply(costs,1, function (r) r*timescale[x,]/timescale[1,])))

# add licence cost column (adjusted for inflation)
ssv_rd_costsamples = lapply( 1:length(costlist), function(x) cbind( rowSums( cbind(costlist[[x]], (1+pall$inflation)*pall$cost_lic)*pto), paste0(dms[x], ' Days Mission')) )

ssv_rd_plot <- as.data.frame(do.call(rbind,ssv_rd_costsamples))
colnames(ssv_rd_plot) = c('Cost','Investment')
ssv_rd_plot$Cost = as.numeric(ssv_rd_plot$Cost)
ggplot(ssv_rd_plot) + geom_histogram(aes(Cost/1e9*18)) +
  facet_wrap(~Investment) +
  theme_bw(base_size=15) +
  labs(x='Billion USD',y='',title='Risk-adjusted R&D cost for 18 SSV candidates')

```

### BPSV

**I have basically assumed the same as SSV except for the numbers given (8 candidates and 18 weeks)**


The BPSV has eight candidates that go through Phase 3 only. The duration is 18 weeks. Thus we write the response cost

\begin{equation}
D_s^{\text{(BP-resRD)}} = \left\\{\begin{array}{lr}8\hat{P}_3\left(\frac{18}{W_{3;365}^{(S)}}\left(\omega T_3^{(n)} + (1-\omega)T_3^{(e)}\right) + (1+I) P_3L\right) \\; & \\; s\in\\{1,2,3\\} \\\\
0  \\; & \\; s\notin\\{1,2,3\\}
\end{array}\right.
(\#eq:bpsvresrd)
\end{equation}


```{r bpsvrd}
set.seed(0)
x = pto_bpsv_phase3 * (18/phase_duration[1,4] * costs[,4] + pos[,4]*(1+pall$inflation)*pall$cost_lic)
ggplot() + geom_histogram(aes(x/1e9)) +
  theme_bw(base_size=15) +
  labs(x='Cost, billion USD',y='',title='Reactive R&D cost for BPSV')

```


## Procurement cost calculation

<span style="color:red;"> Scenario 1: Annual demand under 6.6B  </span>

<span style="color:red;"> Annual demand \* $6.29 \* 1.14 \* 1.2 </span>

<span style="color:red;"> Scenario 2: Annual demand over 6.6B </span>

<span style="color:red;"> Annual demand * $18.94 </span>

### SSV

If we write annual demand in billions as $A_{\cdot,s,y}$, then we would have costs, in billion USD, of:

\begin{equation}
D_{s}^{\text{(S-proc)}} = \min\\{A_{SSV,s,y},M_C\\}\cdot S_R\cdot(1+M_p)\cdot(1+M_f)  + \max\\{A_{SSV,s,y}-M_C,0\\}\cdot S_U
(\#eq:ssvproc)
\end{equation}

Here, $S_R$ is the cost per reserved dose and $S_U$ the cost per unreserved dose. Reserved doses are marked up by $M_p$ and $M_f$. 

The total number of doses produced in week $w$ in scenario $s$ is $Z_{T,s,w}$ (see Equation \@ref(eq:supply)). The total in a one-year period is 

$$A_{SSV,s,y} = \sum_{w\in y}Z_{T,s,w}.$$

```{r sup}

## supply

scen_dm = c(1, 1,1,1, 1,1, 2,2,2, 3,3,3, 1)
scen_capres = c(1, 1,2,3, 2,3, 1,2,3, 1,2,3, 1)

dose_supply = function(week, w0, weeks_init, weeks_scale, man_cap){
  if((week - w0) < weeks_init){
    doses = 0
  }else if((week - w0) < (weeks_init + weeks_scale)){
    doses = man_cap/52 * (week - w0 - weeks_init + 1) / weeks_scale
  }else{
    doses = man_cap/52
  }
  return(doses)
}

nweeks = 208
suffixes = c('res','ex','bui')
weeks_init = sapply(suffixes,function(x)pall[[paste0('weeks_init_',x)]])
weeks_scale = sapply(suffixes,function(x)pall[[paste0('weeks_scale_',x)]])
supplies <- cumulative <- list()
for(i in 1:length(scen_dm)){
  supplies[[i]] = list()
  
  w0 = time_to_approval[scen_dm[i]]
  man_cap_res = c(0.5, 1.2, 2.5)[scen_capres[i]]
  
  man_cap_ex = pall$man_curr - man_cap_res
  man_cap_bui = pall$man_glo - pall$man_curr
  
  man_cap = c(man_cap_res, man_cap_ex, man_cap_bui)
  names(man_cap) = suffixes
  
  for(x in suffixes){
    supplies[[i]][[x]] = c()
    for(w in 1:nweeks){
      supplies[[i]][[x]][w] = dose_supply(week=w, w0=w0, weeks_init=weeks_init[[x]], weeks_scale=weeks_scale[[x]], man_cap=man_cap[[x]])
    }
  }
  
  cumulative[[i]] = cumsum(Reduce("+",supplies[[i]]))
  
}

scennames = c('BAU',paste0('S',sprintf("%02d", 1:12)))

t_supply <- as.data.frame(do.call(rbind,lapply(1:length(scennames),function(x)cbind(scen=scennames[x],doses=cumulative[[x]],week=1:nweeks))))

names(cumulative) = scennames

scens = setDT(data.frame(scen=scennames, capres = scen_capres, dm = scen_dm))
scens[,comb := paste0(capres,dm)]
scens[,N:=.N,by=comb]
sames <- list()
for(un in unique(scens$comb)){
  subscen = subset(scens,comb==un)
  if(nrow(subscen)>1)
    sames[[length(sames)+1]] <- subscen$scen
}
```

```{r costperyear}

cost_per_year <- list()
for(s in 1:length(scennames)){
  sup = supplies[[s]]
  res = sup[[1]]
  exbui = sup[[2]] + sup[[3]]
  annual_res_doses = sapply(1:ceiling(nweeks/52),function(y) sum(na.omit(res[(1:52) + (y-1)*52])))
  annual_exbui_doses = sapply(1:ceiling(nweeks/52),function(y) sum(na.omit(exbui[(1:52) + (y-1)*52])))
  annual_doses = annual_res_doses + annual_exbui_doses
  cost_per_year[[s]] = c(sapply(1:ceiling(nweeks/52), function(y) 
    min(pall$man_curr,annual_doses[y])*pall$cost_res*(1+pall$profit)*(1+pall$cost_ff) + max(annual_doses[y]-pall$man_curr, 0)*pall$cost_un
    ), scennames[s])
}

cpy = data.frame(do.call(rbind,cost_per_year))
colnames(cpy) = c(paste0('Year ',1:ceiling(nweeks/52)),'Scenario')
cpymelt = reshape2::melt(cpy,id.vars='Scenario')
cpymelt$variable = as.numeric(cpymelt$variable)
cpymelt$value = as.numeric(cpymelt$value)

ggplot(cpymelt) + 
  geom_line(aes(x=variable,y=value,colour=Scenario)) +
  theme_bw(base_size=15) +
  labs(x='Year',y='Cost, billion USD')


```


### BPSV


\begin{equation}
D_s^{\text{(BP-proc)}} = \left\\{\begin{array}{lr}
A_{BPSV,s}\cdot G\\; & \\; s\in\\{1,2,3\\} \\\\
0  \\; & \\; s\notin\\{1,2,3\\}
\end{array}\right.
(\#eq:bpsvproc)
\end{equation}


```{r bpsvproc}

ics = c('hic','umic','lmic','lic')
pops = sapply(paste0('pop_',ics,'_15'),function(x)pall[[x]])
pops3 = pops[1:3]
pops3[3] = sum(pops[3:4])


pops65 = sapply(paste0('pop_',ics,'_65'),function(x)pall[[x]])
pops365 = pops65[1:3]
pops365[3] = sum(pops65[3:4])
# popfracs65 = pops365/sum(pops365)

demand65 = 0.8*pops365 # total bpsv doses per income level

bpsvproc = pall$cost_bpsv*sum(demand65)/1e9

```

For a world population aged 65 and over of `r round(sum(pops365)/1e9,1)` billion, and a cost per dose of `r pall$cost_bpsv` USD, and uptake of 80\%, the procurement cost for BPSV is `r round(bpsvproc,2)` billion USD.


## Delivery Cost Equation

<span style="color:red;">  WB status demand/0.8 * 0.1 * (0-10% cost) + WB status demand/0.8  * 0.2 * (11-30% cost) + WB status demand/0.8 * 0.5 * (30-80% cost) </span>

### SSV


For populations aged 15 and above $N_i^{(15)}$ in income group $i\in\{\text{LIC, LMIC, UMIC, HIC}\}$, and delivery cost $D$:

\begin{equation}
D^{\text{(S-del)}} = \sum_{i}N_i^{(15)}\left(\frac{1}{8}V_{i; 0} + \frac{2}{8}V_{i; 11} + \frac{5}{8}V_{i; 31}\right) 
(\#eq:ssvdel)
\end{equation}

We set 

$$V_{LLMIC; j} = \frac{1}{N_{LMIC}^{(15)} + N_{LIC}^{(15)}} \left(N_{LMIC}^{(15)}V_{LMIC; j} + N_{LIC}^{(15)}V_{LIC; j} \right)$$

```{r allocation}


## allocation 

demand15 = 0.8*pops3*2
popfracs15 = pops3/sum(pops3)


allocate_res_doses = function(cum_received, new_doses){
  if(cum_received[1] < 0.5){
    allocation = c(new_doses, 0, 0)
  }else if(cum_received[1] < demand15[1]/1e9){
    allocation = new_doses * popfracs15
  }else if(cum_received[2] < demand15[2]/1e9){
    allocation = c(0, new_doses * pops3[2:3]/sum(pops3[2:3]))
  }else if(cum_received[3] < demand15[3]/1e9){
    allocation = c(0,0,new_doses)
  }else{
    allocation = c(0,0,0)
  }
  return(allocation)
}

allocate_exbui_doses = function(cum_received, new_doses){
  if(cum_received[1] < demand15[1]/1e9){
    allocation = c(new_doses, 0, 0)
  }else if(cum_received[2] < demand15[2]/1e9){
    allocation = c(0, new_doses, 0)
  }else if(cum_received[3] < demand15[3]/1e9){
    allocation = c(0,0,new_doses)
  }else{
    allocation = c(0,0,0)
  }
  return(allocation)
}


pop_proportional = c(1,1,2,2,1,1,1,2,2,1,2,2,2)
function_list = list(res=allocate_res_doses, ex=allocate_exbui_doses, bui=allocate_exbui_doses)
rep_res = list(res=allocate_res_doses, ex=allocate_res_doses, bui=allocate_res_doses)

alloc = list()

for(s in 1:length(scennames)){
  cumulative_doses = matrix(0,nrow=nweeks,ncol=3)
  function_op = list(function_list, rep_res)[[pop_proportional[s]]]
  for(w in 2:nweeks){
    current_count = cumulative_doses[w-1,]
    
    for(x in suffixes){
      new_doses = supplies[[s]][[x]][w]
      allocation_res = function_op[[x]](cum_received = current_count, new_doses=new_doses)
      current_count = current_count + allocation_res
    }
    
    cumulative_doses[w,] = current_count
  }
  alloc[[s]] = as.data.frame(cumulative_doses)
  alloc[[s]]$Scenario = scennames[s]
  alloc[[s]]$Week = 1:nweeks
  colnames(alloc[[s]])[1:3] = c('HIC','UMIC','LLMIC')
}

```


```{r delivery}


## delivery


incomelevels = c('HIC','UMIC','LLMIC')
rates = matrix(rep(c(.07, .07, .02), length(scennames)),ncol=length(incomelevels),byrow=T)
rates[13,3] = 0.04

second_dose_delivery <- all_dose_delivery <- list()
for(s in 1:nrow(rates)){
  second_dose_delivery[[s]] <- all_dose_delivery[[s]] <- list()
  for(il in 1:ncol(rates)){
    rateperdose = rates[s,il]/2
    # new doses in per week
    doses_per_week = c(0, diff(alloc[[s]][,il]))
    first_doses <- second_doses <- c()
    doses_left = 0
    for(w in 1:nweeks){
      # doses this week = stock plus flow
      doses_left = doses_left + doses_per_week[w]
      # first doses given are the minimum of: the delivery rate; the doses left (per population); the fraction of the population still unvaccinated
      first_doses[w] =  min(rateperdose, doses_left/(pops3[il]/1e9), max(0,demand15[il]/pops3[il]/2 - sum(first_doses)) )
      # subtract doses given to update the stock
      doses_left = doses_left - first_doses[w]
      if(w>3){
        # second doses given are the minimum of: the delivery rate; the doses left (per population); the fraction of the population vaccinated once, at least three weeks ago, but not twice.
        second_doses[w] = min(rateperdose, doses_left/(pops3[il]/1e9), max(0, sum(first_doses[1:(w-3)])-sum(second_doses)))
        # subtract doses given to update the stock
        doses_left = doses_left - second_doses[w]
      }else{
        second_doses[w] = 0
      }
    }
    second_dose_delivery[[s]][[il]] = data.frame(doses=cumsum(second_doses), il=incomelevels[il], Week=1:nweeks)
    all_dose_delivery[[s]][[il]] = data.frame(doses=cumsum(second_doses+first_doses))
  }
  second_dose_delivery[[s]] = do.call(rbind,second_dose_delivery[[s]])
  all_dose_delivery[[s]] = do.call(cbind,all_dose_delivery[[s]])
  second_dose_delivery[[s]]$Scenario = scennames[s]
  all_dose_delivery[[s]]$Scenario = scennames[s]
  all_dose_delivery[[s]]$Week = 1:nweeks
}

```


```{r deliverycost}

## cost delivery

# get costs per dose
pcs = c(0,11,31)
icpc = apply(expand.grid(ics,pcs), 1, function(x) paste0('cost_',x[1],'_',as.numeric(x[2])))
cost_per_dose = as.data.frame(sapply(icpc,function(x) pall[[x]]))
popsllmic = pops[3:4]/sum(pops[3:4])
for(i in pcs){
  lic = paste0('cost_lic_',as.numeric(i))
  lmic = paste0('cost_lmic_',as.numeric(i))
  llmic = paste0('cost_llmic_',as.numeric(i))
  cost_per_dose[[llmic]] = popsllmic[1]*cost_per_dose[[lmic]] + popsllmic[2]*cost_per_dose[[lic]]
  cost_per_dose[[lmic]] <- cost_per_dose[[lic]] <- NULL
}

# apply costs per dose to quantiles
##!! can just apply values to the total (rather than going week by week) if there is no discounting
ssv_delivery_costs = matrix(0,ncol=length(scennames),nrow=nsamples)
for(s in 1:length(scennames)){
  scendoses = all_dose_delivery[[s]]
  costvec = rep(1, nrow(scendoses))
  for(j in 1:length(incomelevels)){
    # the jth column is HIC, UMIC or LLMIC
    # which(scendoses[,1] <= 0.1)
    costvec[which(scendoses[,j] > 0.1 & scendoses[,1] <= 0.3)] <- 2
    costvec[which(scendoses[,j] > 0.3)] <- 3
    
    costsamples = sapply(1:length(costvec),function(x) {
      lab = paste0('cost_',tolower(incomelevels)[j],'_',as.numeric(pcs[costvec[x]]))
      cost_per_dose[[lab]]
      })
    
    # add country levels together, multiplying by population size
    ssv_delivery_costs[,s] = ssv_delivery_costs[,s] + pops3[j]/1e9 * apply(costsamples, 1, function(x) sum(x*c(0,diff(scendoses[,j]))))
    
  }
}

ssv_delivery_costs = as.data.frame(ssv_delivery_costs)
colnames(ssv_delivery_costs) = scennames
# apply(ssv_delivery_costs,2,function(x)summary(x-ssv_delivery_costs[,1]))
# apply(ssv_delivery_costs,2,mean)

ggplot(reshape2::melt(ssv_delivery_costs)) +
  geom_boxplot(aes(x=variable,y=value,colour=variable),show.legend=F) +
  theme_bw(base_size=15) +
  labs(x='',y='SSV delivery cost, billion USD')


# lapply(all_dose_delivery,function(x)
#   sapply(1:ceiling(nweeks/52),function(y) 
#     apply(na.omit(x[(1:52) + (y-1)*52, 1:3]), 1, function(z) z*
#     )
# )



```







### BPSV

For the BPSV, which goes only to people aged 65 or older, with populations $N_i^{(65)}$, coverage is reached earlier in the process, so the cost is weighted more heavily towards start up and ramp up:

\begin{equation}
D_s^{\text{(BP-del)}} = 
\left\\{\begin{array}{lr}
\sum_{i}D_{\text{BPSV},i}
\\; & \\; s\in\\{1,2,3\\} \\\\
0  \\; & \\; s\notin\\{1,2,3\\}
\end{array}\right.
(\#eq:bspvdel)
\end{equation}

$$D_{\text{BPSV},i} = 
\left\\{\begin{array}{lr}
N_i^{(65)}V_{i; 0}  & N_i^{(65)}\leq \frac{1}{10}N_i^{(15)} \\\\
\frac{N_i^{(15)}}{10} V_{i; 0} + \left(N_i^{(65)}-\frac{N_i^{(15)}}{10} \right)V_{i; 11}  & \frac{1}{10}N_i^{(15)} \leq N_i^{(65)}\leq \frac{3}{10}N_i^{(15)} \\\\
\frac{N_i^{(15)}}{10} V_{i; 0} + \frac{2}{10}N_i^{(15)} V_{i; 11} + \left(N_i^{(65)}-\frac{3}{10}N_i^{(15)} \right)V_{i; 31} & N_i^{(65)}> \frac{3}{10} N_i^{(15)}
\end{array}\right.$$ 

The logic of this is as follows:

- The increments in cost correspond to numbers of eligible people in the whole population, namely those aged 15 and above.
- If the number of people eligible for the BPSV is less than 10\% of the population aged 15 and over, then all doses cost the "start up" amount.
- If the number of people eligible for the BPSV is more than 10\% and less than 30\% of the 15+ population, then cost of the first doses, a number equal to 10\% of the 15+ population, is the "start up" amount. All remaining doses cost the "ramp up" amount.
- If the number of people eligible for the BPSV is more than 30\% of the 15+ population, then the cost of the first doses, a number equal to 10\% of the 15+ population, is the "start up" amount. The cost of the second tranche of doses, a number equal to 20\% of the 15+ population, is the "ramp up" amount. All remaining doses cost the "getting to scale" amount.


```{r bpsvdelivery}

thresholds = sapply(c(1,3,8)/10,function(x) x*pops3) # points at which costs shift per income level
bpsv_del_cost = 0
for(i in 1:length(incomelevels)){
  icthresh = thresholds[i,]
  icdemand = demand65[i]
  firstcost = cost_per_dose[[paste0('cost_',tolower(incomelevels[i]),'_0')]]
  if(icdemand < icthresh[1]){
    cost = icdemand * firstcost
  }else if(icdemand < icthresh[2]){
    cost = icthresh[1] * firstcost + (icdemand - icthresh[1]) * cost_per_dose[[paste0('cost_',tolower(incomelevels[i]),'_11')]]
  }else{
    cost = icthresh[1] * firstcost + (icthresh[2] - icthresh[1]) * cost_per_dose[[paste0('cost_',tolower(incomelevels[i]),'_11')]]  + (icdemand - icthresh[2]) * cost_per_dose[[paste0('cost_',tolower(incomelevels[i]),'_31')]]
  }
  # print(round(summary(cost/1e9)))
  bpsv_del_cost = bpsv_del_cost + cost
}

  # print((summary(bpsv_del_cost/1e9)))

ggplot() + geom_histogram(aes(x=bpsv_del_cost/1e9)) +
  theme_bw(base_size = 15) +
  labs(x='BPSV delivery cost, billion USD',y='')


  
```


| Country | Country status | Study type | Financial Cost per dose (USD) | Source |
|---|---|---|---|---|
| WHO, Gavi, and UNICEF AMC Estimate | AMC | Top down | 1.66 | @Griffiths2021 |
| UNICEF Global Estimate |  All | Model | 0.73 | @Oyatoye2023 |
| DRC | LIC | Bottom up | 1.91 | @Moi2024 |
| Malawi | LIC | Bottom up | 4.55 | @Ruisch2025 |
| Mozambique | LIC | Bottom up | 0.5 | @Namalela2025 |
| Uganda | LIC | Bottom up | 0.79 | @Tumusiime2024 |
| Bangladesh | LMIC | Bottom up | 0.29 | @Yesmin2024 |
| Cote d'Ivoire | LMIC | Bottom up | 0.67 | @Vaughan2023 |
| Nigeria | LMIC | Bottom up | 0.84 | @Noh2024 |
| Philippines | LMIC | Bottom up | 2.16 | @Banks2023 |
| Vietnam | LMIC | Bottom up | 1.73 | @Nguyen2024 |
| Ghana | LMIC | CVIC tool | 2.2--2.3 | @Nonvignon2022 |
| Lao PDR | LMIC | CVIC tool | 0.79--0.81 | @Yeung2023 |
| Kenya | LMIC | Top down | 3.29--4.28 | @Orangi2022 | 
| Botswana | UMIC | Mixed | 19 | @Vaughan2025 |
| South Africa | UMIC | Top down | 3.84 | @Edoka2024 | 

Table: Literature review of global and country-specific delivery rates. 





# SSV delivery


| Category | Reserved capacity | Private response (existing capacity)  | Private response (built capacity)  |
|---|---|---|---|
| Annual manufacturing volume | By scenario (0.5--2.5B)| 2.5B minus reserved volume | 6B |
| Facility transition start | 7 weeks before vaccine approval | 7 weeks before vaccine approval | 7 weeks before vaccine approval |
| Weeks to initial manufacturing | 12 | 30 | 48 |
| Scale-up weeks to full capacity | 10 | 16 | 16 |

Table: Manufacturing response timeline assumptions 



 

<!-- | Weeks from transition start | 0-11 | 12-21 | 22-29 | 30-45  | 46-47 | 48-63 | 64+ | -->
<!-- |---|---|---|---|---|---|---|---| -->
<!-- | Reserved Capacity (%)  || Scaling from 0-100 | 100 | 100 | 100 | 100 | 100 |  -->
<!-- | Private Capacity (Existing; %)  || | | Scaling from 0-100 | 100 | 100 | 100 |  -->
<!-- | Private Capacity (Response; %)  | | | |  | | Scaling from 0-100 | 100 | -->

 

| Weeks from transition start |	Reserved Capacity (%)	 | Private Capacity (Existing; %)	| Private Capacity (Response; %) |
|---|---|---|---|
| 0--11 |  |  |  |			
| 12--21 |	Scaling from 0-100	 |  |  |				
| 22--29 |	100		|   |  |			
| 30--45 |	100 |	Scaling from 0-100	  |  |
| 46--47 |	100 |	100	  |  |
| 48--63	 |100 |	100 |	Scaling from 0-100 |
| 64+|	100 |	100 |	100 |

Table: Vaccine Production Timeline


## Timing

Facility transition occurs $F=7$ weeks before vaccine approval, which in turn depends on R\&D investments. We have three levels in our scenarios, corresponding to a 100 Days Mission, 200 days, and 365 days. The total weeks taken for vaccine approval can be written as follows:

$$W_{j}^{(S)} = \sum_{i=0}^3 W_{i;j}^{(S)}$$


for $j\in\\{365, 200, 100\\}$. These work out as `r time_to_approval[1]`, `r time_to_approval[2]`, and `r time_to_approval[3]` weeks, respectively. Thus "week 0" for manufacturing occurs `r time_to_approval[1]-7`, `r time_to_approval[2]-7`, and `r time_to_approval[3]-7` weeks, respectively, after the new pathogen has been sequenced. We denote this variable $w_s^{(0)}$.




## Production

The total global manufacturing volume is $M_G=15$ billion doses. The amount that is reserved, in billion doses, depends on the scenarios as follows:

$$M_{R,s} = \left\\{\begin{array}{lr}0.5 & s\in\\{0, 1, 6, 9, 12\\} \\\\ 
1.2 & s\in\\{2, 4, 7, 10\\} \\\\ 
2.5 & s\in\\{3, 5, 8, 11\\} \end{array}\right.$$

where $s=0$ denotes the BAU scenario. By definition, $M_{E,s} = M_C - M_{R,s}$, and $M_B=M_G-M_C$.

Then the number of doses, in billions, that are made from capacity $x\in \\{R, E, B\\}$ in week $w$ of scenario $s$ is:


$$Z_{x,s,w} = \left\\{\begin{array}{lr}0 & w-w_s^{(0)} < I_x \\\\ 
\frac{1}{52}\frac{w-w_s^{(0)}-I_x+1}{C_x}M_{x,s} & w-w_s^{(0)}\in[I_x, I_x+C_x) \\\\ 
\frac{1}{52}M_{x,s}  & w-w_s^{(0)}\geq I_x+C_x
\end{array}\right.$$

<!-- \frac{1}{52}M_{R,s}  & w\in[I_R+C_R, I_E)\\\\  -->
<!-- \frac{1}{52}\left(M_{R,s} + \frac{w-I_E+1}{C_E}M_{E,s}\right) & w\in[I_E, I_E+C_E)\\\\  -->
<!-- \frac{1}{52}\left(M_{R,s} + M_{E,s}\right)  & w\in[I_E+C_E, I_B)\\\\  -->
<!-- \frac{1}{52}\left(M_{R,s} + M_{E,s} + \frac{w-I_B+1}{C_B}M_{B}\right) & w\in[I_B, I_B+C_B)\\\\  -->

where $I_R=12$ is the number of weeks to initial manufacturing for reserved capacity, $C_R=10$ is the number of weeks to scale up to full capacity; $I_E=30$ is the number of weeks to initial manufacturing for existing and unreserved capacity, $C_E=16$ is the number of weeks to scale up to full capacity; $I_B=48$ is the number of weeks to initial manufacturing for built and unreserved capacity, $C_B=16$ is the number of weeks to scale up to full capacity.

Then the total number of doses produced in week $w$ is 

\begin{equation}
Z_{T,s,w} = Z_{R,s,w}+Z_{E,s,w}+Z_{B,s,w}.
(\#eq:supply)
\end{equation}



```{r supply, fig.cap='Doses made available from manufacturing per scenario. Weeks are in reference to the sequencing of the pathogen.'}

ggplot(t_supply) + 
  geom_line(aes(x=as.numeric(week),y=as.numeric(doses),colour=factor(scen,levels=scennames))) +
  theme_bw(base_size = 15) +
  labs(x='Week',y='Cumulative doses manufactured, billions',colour='Scenario')

```

In Figure \@ref(fig:supply), the following scenarios have identical supply (because they have the same capacity reservations and R\&D investments): `r paste0(sames[[1]],collapse=' & ')`; `r paste0(sames[[2]],collapse=' & ')`; and `r paste0(sames[[3]],collapse=' & ')`.

## Allocation

Denote the weekly allocated doses at week $w$ from capacity $x$ to income level $k_{s,x,i,w}$, and the cumulative number $K_{s,i,w}$, such that $$K_{s,i,w} = \sum_{x\in\\{R,E,B\\}}\sum_{j=0}^w k_{s,x,i,j}.$$ We write $X_i = 2\cdot 0.8\cdot N_i^{(15)}$ as the maximum demand for income group $i$, representing two doses each for 80\% of the population.

$$
k_{s,R,i,w} = \left\\{ \begin{array}{lr}
Z_{R,s,w}             & K_{s,\text{HIC},w} < 0.5 \\;\\&\\; i=\text{HIC} \\\\
0                     & K_{s,\text{HIC},w} < 0.5 \\;\\&\\; i\neq\text{HIC} \\\\
\frac{N_{i}}{N_{HIC}+N_{UMIC}+N_{LLMIC}}Z_{R,s,w} & 0.5 < K_{s,\text{HIC},w} < X_{\text{HIC}} \\\\
\frac{N_{i}}{N_{UMIC}+N_{LLMIC}}Z_{R,s,w} & K_{s,\text{HIC},w} \geq X_{\text{HIC}} \\;\\&\\;  K_{s,\text{UMIC},w} < X_{\text{HIC}} \\;\\&\\; i\neq\text{HIC}\\\\
Z_{R,s,w}             & K_{s,\text{UMIC},w} \geq X_{\text{UMIC}} \\;\\&\\; i=\text{LLMIC}
\end{array}\right.
$$

The logic of this reads as follows:

- The first 500 million doses from reserved capacity go exclusively to HIC
- None go to UMIC and LLMIC
- When HIC coverage is between 500 million and its total demand, reserved capacity doses are allocated according to population
- Once HIC reach their total demand, doses from reserved capacity are split proportional to population between UMIC and LLMIC
- Once UMIC reach their total demand, all doses from reserved capacity go to LLMIC




For $x\in\\{E,B\\}$,

$$
k_{s,x,i,w} = \left\\{ \begin{array}{lr}
Z_{x,s,w}            & K_{s,\text{HIC},w} < X_{\text{HIC}} \\;\\&\\; i=\text{HIC} \\\\
0                     & K_{s,\text{HIC},w} < X_{\text{HIC}} \\;\\&\\; i\neq\text{HIC} \\\\
Z_{x,s,w}            & K_{s,\text{HIC},w} \geq X_{\text{HIC}} \\;\\&\\; K_{s,\text{UMIC},w} < X_{\text{UMIC}} \\;\\&\\; i=\text{UMIC} \\\\
0                     & K_{s,\text{HIC},w} \geq X_{\text{HIC}} \\;\\&\\; K_{s,\text{UMIC},w} < X_{\text{UMIC}} \\;\\&\\; i\neq\text{UMIC} \\\\
Z_{x,s,w}            & K_{s,\text{UMIC},w} \geq X_{\text{UMIC}} \\;\\&\\; i=\text{LLMIC} \\\\
0                     & K_{s,\text{UMIC},w} \geq X_{\text{UMIC}} \\;\\&\\; i\neq\text{LLMIC} 
\end{array}\right.
$$

The logic of this reads as follows:

- Until HIC demand is reached, all doses from unreserved capacity go to HIC
- None go to UMIC and LLMIC
- Once HIC demand has been met and until UMIC demand is reached, all doses from unreserved capacity go to UMIC
- None go to HIC and LLMIC
- Once HIC and UMIC demand have been met, all remaining doses from unreserved capacity go to LLMIC
- None go to UMIC and HIC




```{r procurement}

ggplot(reshape2::melt(do.call(rbind,alloc),id.vars=c('Scenario','Week'))) +
  geom_line(aes(x=Week,colour=Scenario,y=value)) +
  facet_wrap(~variable) +
  theme_bw(base_size = 15) +
  labs(x='Week',y='Cumulative doses procured, billions',colour='Scenario')

```

## Delivery

```{r scendelivery}

ggplot(do.call(rbind,second_dose_delivery)) +
  geom_line(aes(x=Week,colour=Scenario,y=doses*100)) +
  facet_wrap(~factor(il,levels=incomelevels)) +
  theme_bw(base_size = 15) +
  labs(x='Week',y='Second-dose coverage, percent population',colour='Scenario')


```



# BPSV delivery



# Parameter samples

```{r parsamples}

for(i in 1:length(params))
  base::print(
    ggplot() + 
      geom_histogram(aes(x=params[[i]])) + 
      theme_bw(base_size = 13) + 
      labs(x='',y='',title=names(params)[i])
    )

```


# Attributions / Authors

# References
